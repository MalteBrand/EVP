function Aufg3(anzRealMC, x_optb)
    addpath(fullfile(".", "Aufg1"))
    addpath(fullfile(".", "Aufg2"))
    addpath(fullfile(".", "Aufg3"))
    [n,m,rmin,rmax,dx,dy,r0,A,E,Fex,k,b,nob,EAs,rs,BCs,loads] = preprocess();
    %u0 = trussFEM2D.solve(k,b,EAs,BCs,loads);
    %trussFEM2D.plotTruss2D(k,b,rs,1,u0,1);
    % stochastische Eingangsgrößen
    mu_stat = k; %Erwartungswert entspricht den unverschobenen Knotenpositionen
    sig_stat = 0.1*0.3; % 10% der kleinsten Stablänge
    lc = 1.5; %Korrelationslänge

    [CovMa,CovSq] = Zufallsfeld(mu_stat, sig_stat, lc, k);

    OpKnoten = (floor(n/2)*m) + 1; %Berechnungvorschrift für Punkt P bzw. Knoten 26 
    x0 = A*ones(nob,1);
    V0 = trussFEM2D.mass(k,b,A);

    fhf = @(x) ziel(x, E, k, b, BCs, loads, OpKnoten,anzRealMC, CovSq, mu_stat);
    fhgtb = @(x) nebenBedingungen4toolbox(x, rmin, rmax, V0, k, b, E, BCs, loads, CovSq, mu_stat);
    
    %Optimierung mit SQP
    %options = optimoptions('fmincon','SpecifyObjectiveGradient',true,'Algorithm','sqp','Display','iter','StepTolerance',0.000000000001);
    options = optimoptions('fmincon','SpecifyObjectiveGradient',true,'SpecifyConstraintGradient',true,'Algorithm','sqp','Display','iter','StepTolerance',0.000000000001);
    x_opt = fmincon(fhf,x0,[],[],[],[],[],[],fhgtb,options);

    A = x_opt;
    EAs = E*A;
    
    %Optimierte Verschiebung
    u = trussFEM2D.solve(k,b,EAs,BCs,loads);
    
    rs = sqrt(A/pi);
    
    %Optimierter Plot ohne Last
    %trussFEM2D.plotTruss2D(k,b,rs,2);
    %Optimierter Plot mit Last
    trussFEM2D.plotTruss2D(k,b,rs,14,u,1);
    
    sig_X = 15;
    mu_X = 0;
    EAs = E*x0;
    %Schleife über die Anzahl der Realisierungen
    for i=1:anzRealMC
    
        x(i) = sig_X * randn + mu_X; %Erzeugen einer normalverteilten Zufallszahl
        loads = [(floor(n/2)+1)*m, 1, x(i);
                 (floor(n/2)+1)*m, 2, Fex]; %Zufallszahl in den Kraftvektor stecken
        u = trussFEM2D.solve(k,b,EAs,BCs,loads); %Verschiebungsw
        g(i,1:2) = u(2*OpKnoten-1:2*OpKnoten)';
    
    
    end

    mu_ref = mean(g)
    var_ref = var(g)
    sig_ref = std(g)

    EAs = E*x_optb;
    %Schleife über die Anzahl der Realisierungen
    for i=1:anzRealMC
    
        x(i) = sig_X * randn + mu_X; %Erzeugen einer normalverteilten Zufallszahl
        loads = [(floor(n/2)+1)*m, 1, x(i);
                 (floor(n/2)+1)*m, 2, Fex]; %Zufallszahl in den Kraftvektor stecken
        u = trussFEM2D.solve(k,b,EAs,BCs,loads); %Verschiebungsw
        g(i,1:2) = u(2*OpKnoten-1:2*OpKnoten)';
    
    
    end

    mu_opt = mean(g)
    var_opt = var(g)
    sig_opt = std(g)

    EAs = E*x_opt;
    %Schleife über die Anzahl der Realisierungen
    for i=1:anzRealMC
    
        x(i) = sig_X * randn + mu_X; %Erzeugen einer normalverteilten Zufallszahl
        loads = [(floor(n/2)+1)*m, 1, x(i);
                 (floor(n/2)+1)*m, 2, Fex]; %Zufallszahl in den Kraftvektor stecken
        u = trussFEM2D.solve(k,b,EAs,BCs,loads); %Verschiebungsw
        g(i,1:2) = u(2*OpKnoten-1:2*OpKnoten)';
    
    
    end

    mu_rob = mean(g)
    var_rob = var(g)
    sig_rob = std(g)

    EAs = E*x0;
    loads = [(floor(n/2)+1)*m, 2, Fex]; %Karftvektor zurücksetzen

    %Schleife über die Anzahl der Realisierungen
    for i=1:anzRealMC
        z = [zeros(5,2);
             randn(length(k)-10,2);
             zeros(5,2)];
        %z = randn(length(k),2);
        x = CovSq * z + mu_stat; %Erzeugen einer Gauß-normalverteilten Zufallszahl
        % Keine Verschiebung der Lagerpunkte
        x = [k(1:5,:);
             x(6:50,:);
             k(51:55,:)];
        u = trussFEM2D.solve(x,b,EAs,BCs,loads); %Verschiebung
        g1(i) = u(2*OpKnoten-1);
        g2(i) = u(2*OpKnoten);
        
    end

    mu_ref2x = mean(g1);
    var_ref2x = var(g1);
    sig_ref2x = std(g1);
    mu_ref2y = mean(g2);
    var_ref2y = var(g2);
    sig_ref2y = std(g2);
    mu_ref2 = [mu_ref2x;mu_ref2y]
    var_ref2 = [var_ref2x;var_ref2y]
    sig_ref2 = [sig_ref2x;sig_ref2y]

    EAs = E*x_optb;
    loads = [(floor(n/2)+1)*m, 2, Fex]; %Karftvektor zurücksetzen

    %Schleife über die Anzahl der Realisierungen
    for i=1:anzRealMC
        z = [zeros(5,2);
             randn(length(k)-10,2);
             zeros(5,2)];
        %z = randn(length(k),2);
        x = CovSq * z + mu_stat; %Erzeugen einer Gauß-normalverteilten Zufallszahl
        % Keine Verschiebung der Lagerpunkte
        x = [k(1:5,:);
             x(6:50,:);
             k(51:55,:)];
        u = trussFEM2D.solve(x,b,EAs,BCs,loads); %Verschiebung
        g1(i) = u(2*OpKnoten-1);
        g2(i) = u(2*OpKnoten);
        
    end

    mu_opt2x = mean(g1);
    var_opt2x = var(g1);
    sig_opt2x = std(g1);
    mu_opt2y = mean(g2);
    var_opt2y = var(g2);
    sig_opt2y = std(g2);
    mu_opt2 = [mu_opt2x;mu_opt2y]
    var_opt2 = [var_opt2x;var_opt2y]
    sig_opt2 = [sig_opt2x;sig_opt2y]

    EAs = E*x_opt;
    loads = [(floor(n/2)+1)*m, 2, Fex]; %Karftvektor zurücksetzen

    %Schleife über die Anzahl der Realisierungen
    for i=1:anzRealMC
        z = [zeros(5,2);
             randn(length(k)-10,2);
             zeros(5,2)];
        %z = randn(length(k),2);
        x = CovSq * z + mu_stat; %Erzeugen einer Gauß-normalverteilten Zufallszahl
        % Keine Verschiebung der Lagerpunkte
        x = [k(1:5,:);
             x(6:50,:);
             k(51:55,:)];
        u = trussFEM2D.solve(x,b,EAs,BCs,loads); %Verschiebung
        g1(i) = u(2*OpKnoten-1);
        g2(i) = u(2*OpKnoten);
        
    end

    mu_rob2x = mean(g1);
    var_rob2x = var(g1);
    sig_rob2x = std(g1);
    mu_rob2y = mean(g2);
    var_rob2y = var(g2);
    sig_rob2y = std(g2);
    mu_rob2 = [mu_rob2x;mu_rob2y]
    var_rob2 = [var_rob2x;var_rob2y]
    sig_rob2 = [sig_rob2x;sig_rob2y]
    
    data1 = [   mu_ref(1), mu_ref(2),var_ref(1), var_ref(2), sig_ref(1),sig_ref(2);
                mu_opt(1), mu_opt(2),var_opt(1), var_opt(2), sig_opt(1),sig_opt(2);
                mu_rob(1), mu_rob(2),var_rob(1), var_rob(2), sig_rob(1),sig_rob(2)];
    data2 = [   mu_ref2(1), mu_ref2(2),var_ref2(1), var_ref2(2), sig_ref2(1),sig_ref2(2);
                mu_opt2(1), mu_opt2(2),var_opt2(1), var_opt2(2), sig_opt2(1),sig_opt2(2);
                mu_rob2(1), mu_rob2(2),var_rob2(1), var_rob2(2), sig_rob2(1),sig_rob2(2)];


    fig = uifigure;
    uitable(fig,'Data', data1, 'ColumnName', {'mu_x', 'mu_y', 'var_x', 'var_y','var_x', 'var_y'});
    title('Vergleich bei streuender Horizontalkraft');
    fig = uifigure;
    uitable(fig,'Data', data2, 'ColumnName', {'mu_x', 'mu_y', 'var_x', 'var_y','var_x', 'var_y'});
    title('Vergleich bei streuenden Knoten');

    function [f,df,ddf] = ziel(x, E, k, b, BCs, loads, OpKnoten,anzRealMC, CovSq, mu_stat)
        
        [mu_u,sigma2_u,dmu_u,dsigma2_u] = MC_FEM_RDO(x, E, k, b, BCs, loads, OpKnoten,anzRealMC, CovSq, mu_stat);
        w1 = 0.5;
        f = w1*( mu_u(2) + 3*sqrt( sigma2_u(2) ) ) + (1-w1)*( mu_u(1) + 3 * sqrt(sigma2_u(1)) ) ;

        df = w1*( dmu_u(2,:) + 3* 1/(2*sqrt( sigma2_u(2) )) * dsigma2_u(2,:) ) + (1-w1)*( dmu_u(1,:) + 3* 1/(2*sqrt( sigma2_u(1))) * dsigma2_u(1,:) );
        ddf = zeros(174,174);
    end

    function [g, dg] = ungl_bed(x, rmin, rmax, k, b, E, BCs, loads, CovSq, mu_stat)

        len = length(x);
        g(1:len)                = -(x - pi*rmin^2); %r > rmin
        g( (len+1):(2*len) )    = -(pi*rmax^2 - x); %r < rmax
        EAs = E*x;
        %[u,~,Ke,K] = trussFEM2D.solve(k,b,EAs,BCs,loads);
        [mu_u,~,dmu_u,~] = MC_FEM_RDO(x, E, k, b, BCs, loads, OpKnoten,anzRealMC, CovSq, mu_stat,1);
        g(2*len+1) = mu_u(2); %g(2*len+1) = u(2 * OpKnoten); % u < 0
        dg = zeros( len,(2*len+1));
         
        dg(:,(1:len)) = -1* eye(len);
        dg(:, (len+1):(2*len)) = eye(len); 
        dg(:,(2*len+1)) = dmu_u(2,:);%gradf(Ke, K, u, x, b, OpKnoten); 
    end

    function [h ,dh] = gl_bed(x,V0,k,b)   
        len = length(x);

        h = (trussFEM2D.mass(k,b,x) - V0); % V = V0 
        
        x1=k(b(:,1),1);
        y1=k(b(:,1),2);
        x2=k(b(:,2),1);
        y2=k(b(:,2),2);

        dh = zeros(len,1);

        for i=1:len
            dh(i,1) = (sqrt((x2(i)-x1(i))^2 + (y2(i)-y1(i))^2));
        end
    
    end

    function [nb,nbeq,dnb,dnbeq] = nebenBedingungen4toolbox(x, rmin, rmax, V0, k, b, E, BCs, loads, CovSq, mu_stat)
        [nb,dnb] = ungl_bed(x, rmin, rmax, k, b, E, BCs, loads, CovSq, mu_stat);
        [nbeq,dnbeq] = gl_bed(x, V0, k, b);
    end


    function [mu_g,sigma2_g,dmu_g,dsigma2_g] = MC_FEM_RDO(x, E, k, b, BCs, loads, OpKnoten,anzRealMC, CovSq, mu_stat,nb)
        if nargin<11
            nb = 0;
        end
        % deterministische Eingangsgrößen
        EAs = E*x;

        rng default;
        g1 = zeros(anzRealMC,1);
        g2 = zeros(anzRealMC,1);
        dg1 = zeros(anzRealMC,174);
        dg2 = zeros(anzRealMC,174);
        dsigma2_g = zeros(2,174);

        % Schleife über Anzahl Realisierungen
        parfor i=1:anzRealMC

            z = [zeros(5,2);
                 randn(length(k)-10,2);
                 zeros(5,2)];


            % Erzeugen von Zufallszahlen
            x_MC = CovSq * z + mu_stat;
            % Keine Verschiebung der Lagerpunkte
            x_MC = [k(1:5,:);
                    x_MC(6:50,:);
                    k(51:55,:)];

            % Auswerten der Zielfunktion
            [u,~,Ke,K] = trussFEM2D.solve(x_MC,b,EAs,BCs,loads);
            if nb == 1
                u = -u;
            end
            g1(i,1) = u(2*OpKnoten-1);
            g2(i,1) = -u(2*OpKnoten);

            dg1(i,:) = gradf(Ke, K, u, x, b, OpKnoten,2);
            dg2(i,:) = gradf(Ke, K, -u, x, b, OpKnoten);
        
            dsigma2_g = dsigma2_g + [g1(i,1)*dg1(i,:); g2(i,1)*dg2(i,:)];

        end

        g = [g1; g2];
	    dg = [dg1;dg2];
        % Mittelwert, Varianz 
        mu_g1 = mean(g1);
        mu_g2 = mean(g2);
        sigma2_g1 = var(g1);
        sigma2_g2 = var(g2);
        if mu_g1 >= 0
            dmu_g1 = mean(dg1,1);
        else
            dmu_g1 = -mean(dg1,1);
        end
        mu_g1 = abs(mu_g1);
        dmu_g2 = mean(dg2,1);

        mu_g = [mu_g1; mu_g2];
        dmu_g = [dmu_g1; dmu_g2];
        sigma2_g = [sigma2_g1; sigma2_g2];
        dsigma2_g = 2/(anzRealMC-1) * dsigma2_g - [2*mu_g1*dmu_g1; 2*mu_g2*dmu_g2];
    end
end